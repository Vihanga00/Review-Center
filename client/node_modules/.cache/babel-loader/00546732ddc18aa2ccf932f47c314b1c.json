{"ast":null,"code":"import { isNil, last, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us';\n/**\n * Create attributed string from text fragments\n *\n * @param  {Array}  fragments\n * @return {Object} attributed string\n */\n\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\n\n\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\n\n\nvar wrapWords = function wrapWords(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  return function (attributedString) {\n    var _engines$wordHyphenat, _engines;\n\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, parts);\n        string += parts.join('');\n      }\n\n      fragments.push({\n        string: string,\n        attributes: run.attributes\n      });\n    }\n\n    return _extends({}, fromFragments(fragments), {\n      syllables: syllables\n    });\n  };\n};\n/**\n * Clone rect\n *\n * @param  {Object}  rect\n * @return {Object} cloned rect\n */\n\n\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n/**\n * Crop upper section of rect\n *\n * @param  {Object}  rect\n * @return {Object} cropped rect\n */\n\n\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n      result = _partition[1];\n\n  return result;\n};\n/**\n * Get paragraph block height\n *\n * @param  {Object}  paragraph block\n * @return {number} paragraph block height\n */\n\n\nvar height$2 = function height(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n/**\n * Calculate run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\n\n\nvar calculateScale = function calculateScale(run) {\n  var _attributes$font;\n\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\n * Get run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\n\n\nvar scale = function scale(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param  {number}  index\n * @param  {Object}  run\n * @return {number} ligature offset\n */\n\n\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n/**\n * Get run font\n *\n * @param  {Object}  run\n * @return {Object} font\n */\n\n\nvar getFont = function getFont(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param  {number}  start code point index\n * @param  {number}  end code point index\n * @param  {Object}  font to generate new glyph\n * @param  {Object} glyph to be sliced\n * @return {Array} sliced glyph parts\n */\n\n\nvar slice$2 = function slice(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, codePoints);\n  return font ? font.layout(string).glyphs : [glyph];\n};\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param  {number}  string index\n * @param  {Object}  run\n * @return {number}  glyph index\n */\n\n\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param  {Array[number]}  list\n * @return {boolean} normalized array\n */\n\n\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n/**\n * Slice run between glyph indices range\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} sliced run\n */\n\n\nvar slice$1 = function slice(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n\n  var runScale = scale(run);\n  var font = getFont(run); // Get glyph start and end indices\n\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run); // Get start and end glyph\n\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex]; // Get start ligature chunks (if any)\n\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : []; // Get end ligature chunks (if any)\n\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph); // Compute new glyphs\n\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex); // Compute new positions\n\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale\n    };\n  };\n\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n/**\n * Get run index that contains passed index\n *\n * @param  {number}  char index\n * @param  {Array}  runs array\n * @return {Array} run index\n */\n\n\nvar runIndexAt$1 = function runIndexAt(n, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= n && n < run.end;\n  });\n};\n/**\n * Filter runs contained between start and end\n *\n * @param  {number}  start\n * @param  {number}  end\n * @param  {Array}  runs\n * @return {boolean} filtered runs\n */\n\n\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n/**\n * Subtract scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} subtracted run\n */\n\n\nvar subtract = function subtract(n, run) {\n  var start = run.start - n;\n  var end = run.end - n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Slice array of runs\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Array}  runs\n * @return {Array} sliced runs\n */\n\n\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\n * Slice attributed string between two indices\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\n\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\n\n\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n/**\n * Returns empty run\n *\n * @return {Object} empty run\n */\n\n\nvar empty$1 = function empty() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param  {number}  length\n * @param  {Array}  glyph indices\n * @return {Array}  extended glyph indices\n */\n\n\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n/**\n * Get glyph for a given code point\n *\n * @param  {number}  codePoint\n * @param  {Object}  font\n * @return {Object}  glyph\n * */\n\n\nvar fromCodePoint = function fromCodePoint(value, font) {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n/**\n * Append glyph to run\n *\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\n\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n/**\n * Append glyph or code point to run\n *\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\n\n\nvar append$1 = function append(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n/**\n * Get string from array of code points\n *\n * @param {Array} code points\n * @return {String} string\n */\n\n\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, codePoints);\n};\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar append = function append(glyph, attributedString) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var codePointsString = stringFromCodePoints(codePoints);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param  {number}  font\n * @return {Object} ellipsis codepoint\n */\n\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n      codePoints = _font$encode[0];\n\n  return parseInt(codePoints[0], 16);\n};\n/**\n * Trucante block with ellipsis\n *\n * @param  {number}  lines quantity\n * @param  {Object}  paragraph block\n * @return {Object} sliced paragraph block\n */\n\n\nvar truncate = function truncate(block) {\n  var _last, _last2, _last2$attributes;\n\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n\n  if (font) {\n    var _Object$assign;\n\n    var index = block.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\n  }\n\n  return block;\n};\n/**\n * Omit attribute from run\n *\n * @param  {Object}  run\n * @return {Object} run without ommited attribute\n */\n\n\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Get run ascent\n *\n * @param  {Object}  run\n * @return {boolean} ascent\n */\n\n\nvar ascent$1 = function ascent(run) {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n/**\n * Get run descent\n *\n * @param  {Object}  run\n * @return {number} descent\n */\n\n\nvar descent = function descent(run) {\n  var _run$attributes, _run$attributes$font;\n\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n/**\n * Get run lineGap\n *\n * @param  {Object}  run\n * @return {number} lineGap\n */\n\n\nvar lineGap = function lineGap(run) {\n  var _run$attributes, _run$attributes$font;\n\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n/**\n * Get run height\n *\n * @param  {Object}  run\n * @return {number} height\n */\n\n\nvar height$1 = function height(run) {\n  var _run$attributes;\n\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n/**\n * Returns attributed string height\n *\n * @param {Object} attributed string\n * @return {number} height\n */\n\n\nvar height = function height(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a\n * @param {Rect} b\n * @returns {Boolean} rects intersects\n */\n\n\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nvar _excluded = [\"excludeRects\"];\n\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\n\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n\n  var _loop = function _loop() {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop();\n  }\n\n  return fragments;\n};\n\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n      rect = _objectWithoutPropertiesLoose(container, _excluded);\n\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\n    return r.y + r.height;\n  }));\n  var currentRect = rect;\n\n  while (currentRect.y < maxY) {\n    var _partition = partition(currentRect, height),\n        lineRect = _partition[0],\n        rest = _partition[1];\n\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, lineRectFragments);\n  }\n\n  return [].concat(lineRects, [currentRect]);\n};\n\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\n\nvar purgeAttachments = function purgeAttachments(attributedString) {\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  var runs = attributedString.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Layout paragraphs inside rectangle\n *\n * @param  {Object} rect\n * @param  {Array} attributed strings\n * @return {Object} layout blocks\n */\n\n\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n\n    var newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\n * Performs line breaking and layout\n *\n * @param  {Object} engines\n * @param  {Object}  layout options\n * @param  {Object} rect\n * @param  {Object} attributed string\n * @return {Object} layout block\n */\n\n\nvar layoutParagraph = function layoutParagraph(engines, options) {\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths[0] -= indent;\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n/**\n * Slice block at given height\n *\n * @param  {number}  height\n * @param  {Object}  paragraph block\n * @return {number} sliced paragraph block\n */\n\n\nvar sliceAtHeight = function sliceAtHeight(height, block) {\n  var newBlock = [];\n  var counter = 0;\n\n  for (var i = 0; i < block.length; i += 1) {\n    var line = block[i];\n    counter += line.box.height;\n\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n\n  return newBlock;\n};\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  container rect\n * @param  {Object}  attributed strings (paragraphs)\n * @return {Array} paragraph blocks\n */\n\n\nvar typesetter = function typesetter(engines, options, container) {\n  return function (attributedStrings) {\n    var blocks = [];\n    var paragraphs = [].concat(attributedStrings);\n    var layoutBlock = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n\n    while (linesCount > 0 && nextParagraph) {\n      var block = layoutBlock(paragraphRect, nextParagraph);\n      var slicedBlock = block.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n\n    return blocks;\n  };\n};\n\nvar DUMMY_CODEPOINT = 123;\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param  {Array}  glyphs\n * @return {Array} glyph indices\n */\n\nvar resolve = function resolve(glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(acc, next);\n  }, []);\n};\n\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes;\n\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n/**\n * Scale run positions\n *\n * @param  {Object}  run\n * @param  {Array}  positions\n * @return {Array} scaled positions\n */\n\n\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\n * Create glyph run\n *\n * @param  {String}  string\n * @param  {Object}  run\n * @return {Object}  glyph run\n */\n\n\nvar layoutRun = function layoutRun(string) {\n  return function (run) {\n    var start = run.start,\n        end = run.end,\n        _run$attributes2 = run.attributes,\n        attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\n    var font = attributes.font;\n    if (!font) return _extends({}, run, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n    var glyphRun = font.layout(runString);\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n    return _extends({}, run, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n/**\n * Generate glyphs for single attributed string\n *\n * @param  {Object}  layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings\n * @return {Array} attributed string with glyphs\n */\n\n\nvar generateGlyphs = function generateGlyphs() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n/**\n * Resolves yOffset for run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\n\n\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolves yOffset for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveYOffset = function resolveYOffset() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n/**\n * Sort runs in ascending order\n *\n * @param  {Array}  runs\n * @return {Array} sorted runs\n */\n\n\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n/**\n * Is run empty (start === end)\n *\n * @param  {Object}  run\n * @return {Object} is run empty\n */\n\n\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\n\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, {});\n  return Object.values(groups);\n};\n\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n        type = _points$i[0],\n        offset = _points$i[1],\n        attributes = _points$i[2];\n\n    if (start !== -1 && start < offset) {\n      res.push({\n        start: start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n\n    start = offset;\n  }\n\n  return res;\n};\n/**\n * Flatten many runs\n *\n * @param  {Array}  runs\n * @return {Array} flatten runs\n */\n\n\nvar flatten = function flatten(runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n/**\n * Returns empty attributed string\n *\n * @return {Object} empty attributed string\n */\n\n\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} processed attributed string\n */\n\n\nvar preprocessRuns = function preprocessRuns(engines, options) {\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n        scriptItemizer = engines.scriptItemizer;\n\n    var _omitFont = omitFont(attributedString),\n        omittedFontRuns = _omitFont.runs;\n\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\n        substitutedRuns = _fontSubstitution.runs;\n\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\n        itemizationRuns = _scriptItemizer.runs;\n\n    var runs = substitutedRuns.concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n/**\n * Get attributed string start value\n *\n * @param  {Object}  attributed string\n * @return {number} start\n */\n\n\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n/**\n * Get attributed string end value\n *\n * @param  {Object}  attributed string\n * @return {number} end\n */\n\n\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n/**\n * Get attributed string length\n *\n * @param  {Object}  glyph string\n * @return {number} end\n */\n\n\nvar length$1 = function length(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\n/**\n * Breaks attributed string into paragraphs\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Array} attributed string array\n */\n\n\nvar splitParagraphs = function splitParagraphs() {\n  return function (attributedString) {\n    var res = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n\n    return res;\n  };\n};\n/**\n * Return positions advance width\n *\n * @param  {Object}  positions\n * @return {number} advance width\n */\n\n\nvar advanceWidth$2 = function advanceWidth(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Return run advance width\n *\n * @param  {Object}  run\n * @return {number} advance width\n */\n\n\nvar advanceWidth$1 = function advanceWidth(run) {\n  return advanceWidth$2(run.positions || []);\n};\n/**\n * Returns attributed string advancewidth\n *\n * @param {Object} attributed string\n * @return {number} advance width\n */\n\n\nvar advanceWidth = function advanceWidth(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n\nvar WHITE_SPACES_CODE = 32;\n/**\n * Check if glyph is white space\n *\n * @param  {Object}  glyph\n * @return {Boolean}  is white space\n * */\n\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n/**\n * Get white space leading positions\n *\n * @param  {Object}  run\n * @return {Array} white space leading positions\n */\n\n\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run leading white space offset\n *\n * @param  {Object}  run\n * @return {number} leading white space offset\n */\n\n\nvar leadingOffset$1 = function leadingOffset(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string leading white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} leading white space offset\n */\n\n\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\nvar reverse = function reverse(array) {\n  return [].concat(array).reverse();\n};\n/**\n * Get white space trailing positions\n *\n * @param  {Object}  run\n * @return {Array} white space trailing positions\n */\n\n\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\n * Get run trailing white space offset\n *\n * @param  {Object}  run\n * @return {number} trailing white space offset\n */\n\n\nvar trailingOffset$1 = function trailingOffset(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n/**\n * Get attributed string trailing white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} trailing white space offset\n */\n\n\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n/**\n * Drop last char of run\n *\n * @param  {Object}  run\n * @return {boolean} run without last char\n */\n\n\nvar dropLast$1 = function dropLast(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n/**\n * Drop last glyph\n *\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar dropLast = function dropLast(attributeString) {\n  var string = dropLast$2(attributeString.string);\n  var runs = adjust(-1, dropLast$1, attributeString.runs);\n  return Object.assign({}, attributeString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\n\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\n\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar justifyLine$1 = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\n\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var _line$runs, _line$runs$;\n\n    var isLastFragment = i === lines.length - 1;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  return function (blocks) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(function (block) {\n      return block.map(blockFinalizer);\n    });\n  };\n};\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n/**\n * Resolve attachments of run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\n\n\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes;\n\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n/**\n * Resolve attachments for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\n\n\nvar resolveAttachments = function resolveAttachments() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || 'left',\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bidiLevel: a.bidiLevel || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\n * Apply default style to run\n *\n * @param  {Object}  run\n * @return {Object} run with styles\n */\n\n\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n/**\n * Apply default attributes for an attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar applyDefaultStyles = function applyDefaultStyles() {\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n/* eslint-disable no-restricted-syntax */\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n *\n * @param  {Object} layout options\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\n\n\nvar verticalAlignment = function verticalAlignment() {\n  return function (attributedString) {\n    attributedString.runs.forEach(function (run) {\n      var attributes = run.attributes;\n      var verticalAlign = attributes.verticalAlign;\n\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param  {Object}  engines\n * @param  {Object}  attributed string\n * @param  {Object}  container rect\n * @param  {Object}  layout options\n * @return {Array} paragraph blocks\n */\n\n\nvar layoutEngine = function layoutEngine(engines) {\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), generateGlyphs(), verticalAlignment(), wrapWords(engines, options));\n\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n\n    return compose(finalizeFragments(engines, options), typesetter(engines, options, container), processParagraphs, splitParagraphs(), preprocessRuns(engines, options), applyDefaultStyles())(attributedString);\n  };\n};\n/* eslint-disable no-plusplus */\n\n\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable max-classes-per-file */\n\n\nvar Node = /*#__PURE__*/function () {\n  function Node(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.toString = function toString() {\n    return this.data.toString();\n  };\n\n  return Node;\n}();\n\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n  }\n\n  var _proto2 = LinkedList.prototype;\n\n  _proto2.isLinked = function isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  };\n\n  _proto2.size = function size() {\n    return this.listSize;\n  };\n\n  _proto2.isEmpty = function isEmpty() {\n    return this.listSize === 0;\n  };\n\n  _proto2.first = function first() {\n    return this.head;\n  };\n\n  _proto2.last = function last() {\n    return this.last;\n  };\n\n  _proto2.toString = function toString() {\n    return this.toArray().toString();\n  };\n\n  _proto2.toArray = function toArray() {\n    var node = this.head;\n    var result = [];\n\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n\n    return result;\n  };\n\n  _proto2.forEach = function forEach(fun) {\n    var node = this.head;\n\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  };\n\n  _proto2.contains = function contains(n) {\n    var node = this.head;\n\n    if (!this.isLinked(n)) {\n      return false;\n    }\n\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n\n      node = node.next;\n    }\n\n    return false;\n  };\n\n  _proto2.at = function at(i) {\n    var node = this.head;\n    var index = 0;\n\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.next;\n      index += 1;\n    }\n\n    return null;\n  };\n\n  _proto2.insertAfter = function insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node;\n    newNode.next = node.next;\n\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.insertBefore = function insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    newNode.prev = node.prev;\n    newNode.next = node;\n\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  };\n\n  _proto2.push = function push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n\n    return this;\n  };\n\n  _proto2.unshift = function unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n\n    return this;\n  };\n\n  _proto2.remove = function remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n\n    this.listSize -= 1;\n    return this;\n  };\n\n  _proto2.pop = function pop() {\n    var node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  _proto2.shift = function shift() {\n    var node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n\n  return LinkedList;\n}();\n\nLinkedList.Node = Node;\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n/**\n * Add scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} added run\n */\n\n\nvar add = function add(n, run) {\n  var start = run.start + n;\n  var end = run.end + n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n/**\n * Get run length\n *\n * @param  {Object}  run\n * @return {number} length\n */\n\n\nvar length = function length(run) {\n  return run.end - run.start;\n};\n/**\n * Concats two runs into one\n *\n * @param  {Object}  first run\n * @param  {Object}  second run\n * @return {Object}  concatenated run\n */\n\n\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n/**\n * Insert glyph to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\n\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\n  if (!glyph) return run; // Split resolves ligature splitting in case new glyph breaks some\n\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\n\n\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n/**\n * Get run index at char index\n *\n * @param  {number}  char index\n * @param  {Object}  attributedString\n * @return {number} run index\n */\n\n\nvar runIndexAt = function runIndexAt(n, string) {\n  return runIndexAt$1(n, string.runs);\n};\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\n\n\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString); // Add glyph to the end if run index invalid\n\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n/**\n * Advance width between two string indices\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} advanced width run\n */\n\n\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {number} advance width\n */\n\n\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\nvar getStyles = function getStyles(attributedString) {\n  var _attributedString$run, _attributedString$run2;\n\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\n\nvar linebreaker = function linebreaker(options) {\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var style = getStyles(attributedString);\n    var nodes = getNodes(attributedString, style, options);\n    var breaks = linebreak(nodes, availableWidths, {\n      tolerance: tolerance\n    }); // Try again with a higher tolerance if the line breaking failed.\n\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance: tolerance\n      });\n    }\n\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\n\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\n\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n\n      factors.push(f);\n    }\n\n    return factors;\n  };\n};\n\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n/* eslint-disable no-multi-assign */\n\n\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\n    var run = _step.value;\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\n      var position = _step2.value;\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\n\n\nvar justification = function justification(options) {\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n/**\n * Returns attributed string ascent\n *\n * @param {Object} attributed string\n * @return {number} ascent\n */\n\n\nvar ascent = function ascent(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n\n  return attributeString.runs.reduce(reducer, 0);\n};\n/* eslint-disable no-param-reassign */\n// The base font size used for calculating underline thickness.\n\n\nvar BASE_FONT_SIZE = 12;\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = lineFragment.overflowLeft || 0;\n    var overflowRight = lineFragment.overflowRight || 0;\n    var maxX = advanceWidth(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\n      var run = lineFragment.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    }\n\n    return lineFragment;\n  };\n};\n\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\n * Resolves unicode script in runs, grouping equal runs together\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\nvar scriptItemizer = function scriptItemizer() {\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt();\n      var script = unicode.getScript(codePoint);\n\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastScript = script;\n      }\n\n      index += char.length;\n    }\n\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\n\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\n\nvar cache = {};\n\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\n\nvar wordHyphenation = function wordHyphenation() {\n  return function (word) {\n    var cacheKey = \"_\" + word;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nvar getFontSize = function getFontSize(value) {\n  return value.attributes.fontSize || 12;\n};\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\n\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (attributedString) {\n    var string = attributedString.string,\n        runs = attributedString.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\n      var run = _step.value;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\n        var char = _step2.value;\n        var font = defaultFont;\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nexport { layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"sources":["D:/review center/client/node_modules/@react-pdf/textkit/lib/textkit.es.js"],"names":["isNil","last","dropLast","dropLast$2","adjust","compose","_extends","_objectWithoutPropertiesLoose","_createForOfIteratorHelperLoose","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","_engines$wordHyphenat","_engines","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","call","i","run","words","slice","split","filter","Boolean","j","parts","apply","join","copy","rect","Object","assign","partition","height","a","b","y","crop","_partition","result","height$2","paragraph","reduce","acc","block","box","calculateScale","_attributes$font","fontSize","unitsPerEm","font","scale","_run$attributes","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","glyphs","glyphIndexAt","_run$glyphIndices","normalize","array","head","map","slice$1","_run$glyphs","_run$glyphs2","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","startPositions","positions","endPositions","flat","runIndexAt$1","runIndexAt","n","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","empty","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","_glyph$codePoints","glyphLength","append$1","append","stringFromCodePoints","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","_font$encode","parseInt","truncate","_last","_last2","_last2$attributes","_Object$assign","codePoint","lastBlock","omit","ascent$1","ascent","_run$attributes$attac","_run$attributes2","_run$attributes2$font","attachmentHeight","attachment","fontAscent","descent","_run$attributes$font","fontDescent","lineGap","height$1","lineHeight","attributeString","reducer","intersects","x","num1","width","num2","_excluded","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","_loop","pieces","generateLineRects","container","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","line","_line$runs","_line$runs$","lineIndent","style","newLine","layoutParagraph","_paragraph$runs","_paragraph$runs$","_paragraph$runs$$attr","availableWidths","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","blocks","paragraphs","layoutBlock","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","yAdvance","xOffset","yOffset","layoutRun","runString","glyphRun","generateGlyphs","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","res","points","attrs","stack","_points$i","type","splice","flatten","emptyRuns","regularRuns","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","_omitFont","omittedFontRuns","_fontSubstitution","substitutedRuns","_scriptItemizer","itemizationRuns","length$1","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","reverse","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","justifyLine","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bidiLevel","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","underline","underlineColor","underlineStyle","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","layoutEngine","processParagraph","processParagraphs","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","pow","abs","applyBestFit","nodes","count","breakpoints","breakpoint","Node","data","prev","_proto","prototype","toString","LinkedList","tail","listSize","_proto2","isLinked","size","first","toArray","fun","contains","at","listLength","insertAfter","newNode","insertBefore","unshift","remove","pop","linebreak","settings","demerits","flagged","fitness","tolerance","activeNodes","lineLengths","breaks","tmp","fitnessClass","totals","previous","computeCost","active","currentLine","infinity","computeSum","breakPointIndex","mainLoop","candidates","tmpSum","currentClass","candidate","undefined","glue","hyphenated","add","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","insertGlyph","leadingRun","trailingRun","insert","runIndex","advanceWidthBetween$1","advanceWidthBetween","runStart","glyphStartIndex","glyphEndIndex","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","prevNode","getNodes","_ref","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","_value","getStyles","_attributedString$run","_attributedString$run2","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","direction","expandCharFactor","shrinkCharFactor","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","_priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","_f","dist","_iterator","_step","done","_iterator2","_step2","BASE_FONT_SIZE","lineFragment","maxX","decorationLines","thickness","floor","_rect","_line","ignoredScripts","lastScript","char","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","getFontSize","lastFont","_fontSize","defaultFont","default"],"mappings":"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","sourcesContent":["import { isNil, last, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us';\n\n/**\n * Create attributed string from text fragments\n *\n * @param  {Array}  fragments\n * @return {Object} attributed string\n */\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push({\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param  {String} word\n * @return {Array} same word\n */\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n\n/**\n * Wrap words of attribute string\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string including syllables\n */\nvar wrapWords = function wrapWords(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  return function (attributedString) {\n    var _engines$wordHyphenat, _engines;\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, parts);\n        string += parts.join('');\n      }\n      fragments.push({\n        string: string,\n        attributes: run.attributes\n      });\n    }\n    return _extends({}, fromFragments(fragments), {\n      syllables: syllables\n    });\n  };\n};\n\n/**\n * Clone rect\n *\n * @param  {Object}  rect\n * @return {Object} cloned rect\n */\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\n * Crop upper section of rect\n *\n * @param  {Object}  rect\n * @return {Object} cropped rect\n */\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n    result = _partition[1];\n  return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param  {Object}  paragraph block\n * @return {number} paragraph block height\n */\nvar height$2 = function height(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n\n/**\n * Calculate run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\nvar calculateScale = function calculateScale(run) {\n  var _attributes$font;\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n\n/**\n * Get run scale\n *\n * @param  {Object}  run\n * @return {number} scale\n */\nvar scale = function scale(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param  {number}  index\n * @param  {Object}  run\n * @return {number} ligature offset\n */\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n\n/**\n * Get run font\n *\n * @param  {Object}  run\n * @return {Object} font\n */\nvar getFont = function getFont(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param  {number}  start code point index\n * @param  {number}  end code point index\n * @param  {Object}  font to generate new glyph\n * @param  {Object} glyph to be sliced\n * @return {Array} sliced glyph parts\n */\nvar slice$2 = function slice(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, codePoints);\n  return font ? font.layout(string).glyphs : [glyph];\n};\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param  {number}  string index\n * @param  {Object}  run\n * @return {number}  glyph index\n */\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param  {Array[number]}  list\n * @return {boolean} normalized array\n */\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n\n/**\n * Slice run between glyph indices range\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} sliced run\n */\nvar slice$1 = function slice(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n  var runScale = scale(run);\n  var font = getFont(run);\n\n  // Get glyph start and end indices\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run);\n\n  // Get start and end glyph\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\n\n  // Get start ligature chunks (if any)\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n\n  // Get end ligature chunks (if any)\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph);\n\n  // Compute new glyphs\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n\n  // Compute new positions\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale\n    };\n  };\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\n * Get run index that contains passed index\n *\n * @param  {number}  char index\n * @param  {Array}  runs array\n * @return {Array} run index\n */\nvar runIndexAt$1 = function runIndexAt(n, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= n && n < run.end;\n  });\n};\n\n/**\n * Filter runs contained between start and end\n *\n * @param  {number}  start\n * @param  {number}  end\n * @param  {Array}  runs\n * @return {boolean} filtered runs\n */\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * Subtract scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} subtracted run\n */\nvar subtract = function subtract(n, run) {\n  var start = run.start - n;\n  var end = run.end - n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\n * Slice array of runs\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Array}  runs\n * @return {Array} sliced runs\n */\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n\n/**\n * Slice attributed string between two indices\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param  {Object}  attributedString\n * @return {Object} attributedString\n */\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\n * Returns empty run\n *\n * @return {Object} empty run\n */\nvar empty$1 = function empty() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param  {number}  length\n * @param  {Array}  glyph indices\n * @return {Array}  extended glyph indices\n */\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\n * Get glyph for a given code point\n *\n * @param  {number}  codePoint\n * @param  {Object}  font\n * @return {Object}  glyph\n * */\nvar fromCodePoint = function fromCodePoint(value, font) {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * Append glyph to run\n *\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n\n/**\n * Append glyph or code point to run\n *\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object} run with glyph\n */\nvar append$1 = function append(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param {Array} code points\n * @return {String} string\n */\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, codePoints);\n};\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\nvar append = function append(glyph, attributedString) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var codePointsString = stringFromCodePoints(codePoints);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param  {number}  font\n * @return {Object} ellipsis codepoint\n */\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n    codePoints = _font$encode[0];\n  return parseInt(codePoints[0], 16);\n};\n\n/**\n * Trucante block with ellipsis\n *\n * @param  {number}  lines quantity\n * @param  {Object}  paragraph block\n * @return {Object} sliced paragraph block\n */\nvar truncate = function truncate(block) {\n  var _last, _last2, _last2$attributes;\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n  if (font) {\n    var _Object$assign;\n    var index = block.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\n  }\n  return block;\n};\n\n/**\n * Omit attribute from run\n *\n * @param  {Object}  run\n * @return {Object} run without ommited attribute\n */\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n\n/**\n * Get run ascent\n *\n * @param  {Object}  run\n * @return {boolean} ascent\n */\nvar ascent$1 = function ascent(run) {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * Get run descent\n *\n * @param  {Object}  run\n * @return {number} descent\n */\nvar descent = function descent(run) {\n  var _run$attributes, _run$attributes$font;\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\n * Get run lineGap\n *\n * @param  {Object}  run\n * @return {number} lineGap\n */\nvar lineGap = function lineGap(run) {\n  var _run$attributes, _run$attributes$font;\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n\n/**\n * Get run height\n *\n * @param  {Object}  run\n * @return {number} height\n */\nvar height$1 = function height(run) {\n  var _run$attributes;\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * Returns attributed string height\n *\n * @param {Object} attributed string\n * @return {number} height\n */\nvar height = function height(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n  return attributeString.runs.reduce(reducer, 0);\n};\n\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a\n * @param {Rect} b\n * @returns {Boolean} rects intersects\n */\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nvar _excluded = [\"excludeRects\"];\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n  var _loop = function _loop() {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop();\n  }\n  return fragments;\n};\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n    rect = _objectWithoutPropertiesLoose(container, _excluded);\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\n    return r.y + r.height;\n  }));\n  var currentRect = rect;\n  while (currentRect.y < maxY) {\n    var _partition = partition(currentRect, height),\n      lineRect = _partition[0],\n      rest = _partition[1];\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, lineRectFragments);\n  }\n  return [].concat(lineRects, [currentRect]);\n};\n\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\nvar purgeAttachments = function purgeAttachments(attributedString) {\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  var runs = attributedString.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n\n/**\n * Layout paragraphs inside rectangle\n *\n * @param  {Object} rect\n * @param  {Array} attributed strings\n * @return {Object} layout blocks\n */\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n    var newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n\n/**\n * Performs line breaking and layout\n *\n * @param  {Object} engines\n * @param  {Object}  layout options\n * @param  {Object} rect\n * @param  {Object} attributed string\n * @return {Object} layout block\n */\nvar layoutParagraph = function layoutParagraph(engines, options) {\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths[0] -= indent;\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\n * Slice block at given height\n *\n * @param  {number}  height\n * @param  {Object}  paragraph block\n * @return {number} sliced paragraph block\n */\nvar sliceAtHeight = function sliceAtHeight(height, block) {\n  var newBlock = [];\n  var counter = 0;\n  for (var i = 0; i < block.length; i += 1) {\n    var line = block[i];\n    counter += line.box.height;\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n  return newBlock;\n};\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  container rect\n * @param  {Object}  attributed strings (paragraphs)\n * @return {Array} paragraph blocks\n */\nvar typesetter = function typesetter(engines, options, container) {\n  return function (attributedStrings) {\n    var blocks = [];\n    var paragraphs = [].concat(attributedStrings);\n    var layoutBlock = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n    while (linesCount > 0 && nextParagraph) {\n      var block = layoutBlock(paragraphRect, nextParagraph);\n      var slicedBlock = block.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n    return blocks;\n  };\n};\n\nvar DUMMY_CODEPOINT = 123;\n\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param  {Array}  glyphs\n * @return {Array} glyph indices\n */\nvar resolve = function resolve(glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(acc, next);\n  }, []);\n};\n\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n\n/**\n * Scale run positions\n *\n * @param  {Object}  run\n * @param  {Array}  positions\n * @return {Array} scaled positions\n */\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n\n/**\n * Create glyph run\n *\n * @param  {String}  string\n * @param  {Object}  run\n * @return {Object}  glyph run\n */\nvar layoutRun = function layoutRun(string) {\n  return function (run) {\n    var start = run.start,\n      end = run.end,\n      _run$attributes2 = run.attributes,\n      attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\n    var font = attributes.font;\n    if (!font) return _extends({}, run, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n    var glyphRun = font.layout(runString);\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n    return _extends({}, run, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n\n/**\n * Generate glyphs for single attributed string\n *\n * @param  {Object}  layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings\n * @return {Array} attributed string with glyphs\n */\nvar generateGlyphs = function generateGlyphs() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\n * Resolves yOffset for run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n\n/**\n * Resolves yOffset for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\nvar resolveYOffset = function resolveYOffset() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\n * Sort runs in ascending order\n *\n * @param  {Array}  runs\n * @return {Array} sorted runs\n */\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n\n/**\n * Is run empty (start === end)\n *\n * @param  {Object}  run\n * @return {Object} is run empty\n */\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, {});\n  return Object.values(groups);\n};\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n      type = _points$i[0],\n      offset = _points$i[1],\n      attributes = _points$i[2];\n    if (start !== -1 && start < offset) {\n      res.push({\n        start: start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n    start = offset;\n  }\n  return res;\n};\n\n/**\n * Flatten many runs\n *\n * @param  {Array}  runs\n * @return {Array} flatten runs\n */\nvar flatten = function flatten(runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @return {Object} empty attributed string\n */\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} processed attributed string\n */\nvar preprocessRuns = function preprocessRuns(engines, options) {\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n      scriptItemizer = engines.scriptItemizer;\n    var _omitFont = omitFont(attributedString),\n      omittedFontRuns = _omitFont.runs;\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\n      substitutedRuns = _fontSubstitution.runs;\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\n      itemizationRuns = _scriptItemizer.runs;\n    var runs = substitutedRuns.concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\n * Get attributed string start value\n *\n * @param  {Object}  attributed string\n * @return {number} start\n */\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * Get attributed string end value\n *\n * @param  {Object}  attributed string\n * @return {number} end\n */\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * Get attributed string length\n *\n * @param  {Object}  glyph string\n * @return {number} end\n */\nvar length$1 = function length(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\n\n/**\n * Breaks attributed string into paragraphs\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Array} attributed string array\n */\nvar splitParagraphs = function splitParagraphs() {\n  return function (attributedString) {\n    var res = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n    return res;\n  };\n};\n\n/**\n * Return positions advance width\n *\n * @param  {Object}  positions\n * @return {number} advance width\n */\nvar advanceWidth$2 = function advanceWidth(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Return run advance width\n *\n * @param  {Object}  run\n * @return {number} advance width\n */\nvar advanceWidth$1 = function advanceWidth(run) {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\n * Returns attributed string advancewidth\n *\n * @param {Object} attributed string\n * @return {number} advance width\n */\nvar advanceWidth = function advanceWidth(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n  return attributeString.runs.reduce(reducer, 0);\n};\n\nvar WHITE_SPACES_CODE = 32;\n\n/**\n * Check if glyph is white space\n *\n * @param  {Object}  glyph\n * @return {Boolean}  is white space\n * */\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * Get white space leading positions\n *\n * @param  {Object}  run\n * @return {Array} white space leading positions\n */\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run leading white space offset\n *\n * @param  {Object}  run\n * @return {number} leading white space offset\n */\nvar leadingOffset$1 = function leadingOffset(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Get attributed string leading white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} leading white space offset\n */\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\nvar reverse = function reverse(array) {\n  return [].concat(array).reverse();\n};\n\n/**\n * Get white space trailing positions\n *\n * @param  {Object}  run\n * @return {Array} white space trailing positions\n */\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run trailing white space offset\n *\n * @param  {Object}  run\n * @return {number} trailing white space offset\n */\nvar trailingOffset$1 = function trailingOffset(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param  {Object}  attributed string\n * @return {number} trailing white space offset\n */\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\n * Drop last char of run\n *\n * @param  {Object}  run\n * @return {boolean} run without last char\n */\nvar dropLast$1 = function dropLast(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * Drop last glyph\n *\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\nvar dropLast = function dropLast(attributeString) {\n  var string = dropLast$2(attributeString.string);\n  var runs = adjust(-1, dropLast$1, attributeString.runs);\n  return Object.assign({}, attributeString, {\n    string: string,\n    runs: runs\n  });\n};\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\nvar justifyLine$1 = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  return function (line, i, lines) {\n    var _line$runs, _line$runs$;\n    var isLastFragment = i === lines.length - 1;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  return function (blocks) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(function (block) {\n      return block.map(blockFinalizer);\n    });\n  };\n};\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n\n/**\n * Resolve attachments of run\n *\n * @param  {Object}  run\n * @return {Object} run\n */\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes;\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n\n/**\n * Resolve attachments for multiple paragraphs\n *\n * @param  {Object} layout engines\n * @param  {Object}  layout options\n * @param  {Array}  attributed strings (paragraphs)\n * @return {Array} attributed strings (paragraphs)\n */\nvar resolveAttachments = function resolveAttachments() {\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || 'left',\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bidiLevel: a.bidiLevel || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n\n/**\n * Apply default style to run\n *\n * @param  {Object}  run\n * @return {Object} run with styles\n */\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n\n/**\n * Apply default attributes for an attributed string\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\nvar applyDefaultStyles = function applyDefaultStyles() {\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n *\n * @param  {Object} layout options\n * @param  {Object} attributed string\n * @return {Object} attributed string\n */\nvar verticalAlignment = function verticalAlignment() {\n  return function (attributedString) {\n    attributedString.runs.forEach(function (run) {\n      var attributes = run.attributes;\n      var verticalAlign = attributes.verticalAlign;\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param  {Object}  engines\n * @param  {Object}  attributed string\n * @param  {Object}  container rect\n * @param  {Object}  layout options\n * @return {Array} paragraph blocks\n */\nvar layoutEngine = function layoutEngine(engines) {\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), generateGlyphs(), verticalAlignment(), wrapWords(engines, options));\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n    return compose(finalizeFragments(engines, options), typesetter(engines, options, container), processParagraphs, splitParagraphs(), preprocessRuns(engines, options), applyDefaultStyles())(attributedString);\n  };\n};\n\n/* eslint-disable no-plusplus */\nvar INFINITY = 10000;\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n    return 0;\n  };\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n        position = j - 1;\n      }\n      break;\n    }\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n  return breakpoints;\n};\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\nvar Node = /*#__PURE__*/function () {\n  function Node(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n  var _proto = Node.prototype;\n  _proto.toString = function toString() {\n    return this.data.toString();\n  };\n  return Node;\n}();\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n  }\n  var _proto2 = LinkedList.prototype;\n  _proto2.isLinked = function isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  };\n  _proto2.size = function size() {\n    return this.listSize;\n  };\n  _proto2.isEmpty = function isEmpty() {\n    return this.listSize === 0;\n  };\n  _proto2.first = function first() {\n    return this.head;\n  };\n  _proto2.last = function last() {\n    return this.last;\n  };\n  _proto2.toString = function toString() {\n    return this.toArray().toString();\n  };\n  _proto2.toArray = function toArray() {\n    var node = this.head;\n    var result = [];\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n    return result;\n  };\n  _proto2.forEach = function forEach(fun) {\n    var node = this.head;\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  };\n  _proto2.contains = function contains(n) {\n    var node = this.head;\n    if (!this.isLinked(n)) {\n      return false;\n    }\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n      node = node.next;\n    }\n    return false;\n  };\n  _proto2.at = function at(i) {\n    var node = this.head;\n    var index = 0;\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n      node = node.next;\n      index += 1;\n    }\n    return null;\n  };\n  _proto2.insertAfter = function insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  };\n  _proto2.insertBefore = function insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  };\n  _proto2.push = function push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n    return this;\n  };\n  _proto2.unshift = function unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n    return this;\n  };\n  _proto2.remove = function remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n    this.listSize -= 1;\n    return this;\n  };\n  _proto2.pop = function pop() {\n    var node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n  _proto2.shift = function shift() {\n    var node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n  return LinkedList;\n}();\nLinkedList.Node = Node;\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n      return linebreak.infinity;\n    }\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n      return linebreak.infinity;\n    }\n\n    // perfect match\n    return 0;\n  }\n\n  // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode;\n\n    // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }];\n\n      // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine);\n\n        // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        }\n\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3);\n\n          // Positive penalty\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\n            // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\n            // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          }\n\n          // Calculate the fitness class for this candidate active node.\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          }\n\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          }\n\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\n          demerits += active.data.demerits;\n\n          // Only store the best candidate for each fitness class\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n        active = next;\n\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n      tmpSum = computeSum(index);\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  }\n\n  // Add an active node for the start of the paragraph.\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null)));\n\n  // eslint-disable-next-line no-shadow\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n    return breaks.reverse();\n  }\n  return [];\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\n/**\n * Add scalar to run\n *\n * @param  {number}  scalar\n * @param  {Object}  run\n * @return {Object} added run\n */\nvar add = function add(n, run) {\n  var start = run.start + n;\n  var end = run.end + n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\n * Get run length\n *\n * @param  {Object}  run\n * @return {number} length\n */\nvar length = function length(run) {\n  return run.end - run.start;\n};\n\n/**\n * Concats two runs into one\n *\n * @param  {Object}  first run\n * @param  {Object}  second run\n * @return {Object}  concatenated run\n */\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n\n/**\n * Insert glyph to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object}  glyph\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\n  if (!glyph) return run;\n\n  // Split resolves ligature splitting in case new glyph breaks some\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param  {number}  string index\n * @param  {Object | number}  glyph | codePoint\n * @param  {Object}  run\n * @return {Object}  run with glyph\n */\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * Get run index at char index\n *\n * @param  {number}  char index\n * @param  {Object}  attributedString\n * @return {number} run index\n */\nvar runIndexAt = function runIndexAt(n, string) {\n  return runIndexAt$1(n, string.runs);\n};\n\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index\n * @param {Object} glyph\n * @param {Object} attributed string\n * @return {Object} attributed string with new glyph\n */\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString);\n\n  // Add glyph to the end if run index invalid\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\n/**\n * Advance width between two string indices\n *\n * @param  {number}  start glyph index\n * @param  {number}  end glyph index\n * @param  {Object}  run\n * @return {Object} advanced width run\n */\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param  {number}  start offset\n * @param  {number}  end offset\n * @param  {Object}  attributedString\n * @return {number} advance width\n */\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1];\n\n    // Last breakpoint corresponds to K&P mandatory final glue\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n    start = end;\n    return [].concat(acc, [line]);\n  }, []);\n\n  // Last line\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, _value, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\nvar getStyles = function getStyles(attributedString) {\n  var _attributedString$run, _attributedString$run2;\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\nvar linebreaker = function linebreaker(options) {\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var style = getStyles(attributedString);\n    var nodes = getNodes(attributedString, style, options);\n    var breaks = linebreak(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n\n    // Try again with a higher tolerance if the line breaking failed.\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance: tolerance\n      });\n    }\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n      factors.push(f);\n    }\n    return factors;\n  };\n};\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\n/* eslint-disable no-multi-assign */\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  }\n\n  // sum the factors at each priority\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  }\n\n  // choose the priorities that need to be applied\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      }\n\n      // if this priority covers the remaining gap, we're done\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      }\n\n      // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n      priorities[priority] = 1;\n      remainingGap -= prioritySum;\n\n      // if this priority has unconstrained glyphs, let them consume the remaining space\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  }\n\n  // zero out remaining priorities (if any)\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  }\n\n  // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  }\n\n  // create and return an array of distances to add to each glyph's advance\n  var distances = [];\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    }\n\n    // if this glyph is unconstrained, add the unconstrained distance as well\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\n\n/**\n * Adjust run positions by given distances\n *\n * @param {Array} distances\n * @param {Object} line\n * @returns {Object} line\n */\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\n    var run = _step.value;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\n      var position = _step2.value;\n      position.xAdvance += distances[index++];\n    }\n  }\n  return line;\n};\n\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * //TODO: Make it immutable\n *\n * @param {Object} layout options\n * @param {Object} line\n * @returns {Object} line\n */\nvar justification = function justification(options) {\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\n * Returns attributed string ascent\n *\n * @param {Object} attributed string\n * @return {number} ascent\n */\nvar ascent = function ascent(attributeString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n  return attributeString.runs.reduce(reducer, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\n// The base font size used for calculating underline thickness.\nvar BASE_FONT_SIZE = 12;\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = lineFragment.overflowLeft || 0;\n    var overflowRight = lineFragment.overflowRight || 0;\n    var maxX = advanceWidth(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\n      var run = lineFragment.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n      if (run.attributes.strike) {\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n      x += width;\n    }\n    return lineFragment;\n  };\n};\n\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n\n/**\n * Resolves unicode script in runs, grouping equal runs together\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\nvar scriptItemizer = function scriptItemizer() {\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt();\n      var script = unicode.getScript(codePoint);\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n        lastIndex = index;\n        lastScript = script;\n      }\n      index += char.length;\n    }\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\nvar cache = {};\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\nvar wordHyphenation = function wordHyphenation() {\n  return function (word) {\n    var cacheKey = \"_\" + word;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nvar getFontSize = function getFontSize(value) {\n  return value.attributes.fontSize || 12;\n};\n\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\nvar fontSubstitution = function fontSubstitution() {\n  return function (attributedString) {\n    var string = attributedString.string,\n      runs = attributedString.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\n      var run = _step.value;\n      var _fontSize = getFontSize(run);\n      var defaultFont = run.attributes.font;\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\n        var char = _step2.value;\n        var font = defaultFont;\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n          lastFont = font;\n          lastIndex = index;\n        }\n        index += char.length;\n      }\n    }\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nexport { layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\n"]},"metadata":{},"sourceType":"module"}